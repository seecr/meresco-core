===========================
 Meresco Component Library
===========================
---------------------------------------------------------
 About Components, Application DNA and Jackson Pipelines
---------------------------------------------------------
:Identifier: $Id::                             $
:Date: $Date::                     $
:Revision: $Revision$
:Authors: Erik J. Groeneveld
:Last changed by: $LastChangedBy$
:Contact: info@cq2.org
:Copyright: Â© Seek You Too
:License: http://creativecommons.org/licenses/by-nc-nd/3.0/

.. contents::
.. section-numbering::

Introduction
============
Meresco features a generic Component Library to pull components together in order to create a functional system. The type of systems it creates varies from simple metadata storage, to full blown service providers.

The Component Library is one of its kind. It is the one of the simplest Plug & Play solutions around, yet it makes many hard issues such as dependencies, configuration and dataflow easy to deal with.  Also, it yields a very efficient high-performance application.

Problems
--------

Dependencies
~~~~~~~~~~~~
Components reuse other components.  When this happens recursively, a tree of dependent components arises.  The situation become even more complicated when components are not arranged in a pure tree, but in an arbitrary graph.  Component frameworks that try to solve all these problems tend to become complicated; instead of making live easier, they become a problem in their own right.

Configuration
~~~~~~~~~~~~~
In order to function properly, components may need to be configured.  For example, a component might need a directory to write files, or an address to read information from.  Configuration of the components in a tree or arbitrary graph becomes increasingly difficult as not only the dependencies have to be specified, but each component has to be fed with the proper configuration values as well.  This even further complicates component solutions.

Testability
~~~~~~~~~~~
Components to be plugged into a component framework often need to follow strict rules to make them work with it.  At the same time, these rules make them harder to unittest.  Not to mention the need for testing the cooperation of a group of components.  When plugged into a framework, such a group of components is often next to impossible to test.  This especially holds true when the component solution is a server framework, such as J2EE or Apache.

Dataflow
~~~~~~~~
Once components are connected into a graph, they exchange data.  The main issue here is the efficiency by which the data exchange takes place. A framework facilitates this, but must not impose too much overhead doing so. In fact, components might establish any type of transport, using any type of interface they prefer; a framework must allow this and not predetermine the interfaces to be used.

Aspects
~~~~~~~
As each of the issues mentioned above can make a framework a complicated, frightening piece of software, aspects can do so even more.  Relatively simple concepts such as logging or transactions often cause component frameworks to explode in complexity.  This results in additional requirements for components, such as the obligatory support for auxilary interfaces that are not of any relevance to the core functionality of the components.

Obtrusiveness
~~~~~~~~~~~~~
Writing a components to perform a specific job, must be focussed on the specific job for at least 99% of the time. Only a slight effort is allowed for making it work with a framework.  A framework must not be obtrusive towards component programmers.  However, many of todays frameworks require highly skilled experts and a lot of effort to create components for.

Solution
--------
Others
~~~~~~
Many solutions have been tried.  The most well-known is the XML configuration file.  This file describes all components, their dependencies and their parameters.  Components must be present in a directory or a pathlist and must support certain base interfaces to be able to plug and play.  Either the configuration file or the components themselves provide information about supported and required interfaces, and the framework solves the puzzle of how to connect them, often making use of factories.  Among the most prominent examples are Apache, Eclipse and Solr.  However, none of these is simple enough and separates the concerns mentioned above well enough.  A simpler and less obtrusive component solution is needed.

Meresco
~~~~~~~
The Meresco Component Library takes into account all these problems and tries to give a simple solution for it.  This solution:

#. is lightweight, with little overhead regarding memory and CPU usage.

#. is a library and not a framework, which means the application stays in control.

#. allows partial configuration, to make testing easier.

#. supports sharing of configuration data, to avoid duplication of configuration parameters.

#. imposes litte or no contrainsts on components, so they can be easily reused in very different functional applications.

#. supports efficient dataflow between components.

#. has an easy human readable and well-known syntax.

#. has no predefined components for magic functionality.

#. supports aspects to be implemented as just another component.


About Creativity
----------------
The Component Library is the result of over a decade of learning and well over a year of experimenting, revising and refactoring.  It can be said that it is discovered rather than created.  This document does not even try to capture the reasoning during this process of creativity.  It just presents it as it is.  Readers interested in the reasons why are encouraged to e-mail the authors.



The Component Library
=====================

Base Technologies
-----------------
The Component Library uses a few fundamental concepts and technologies:

#. Python and 'pythonic' interfaces to software written in C++, Java, Perl, Ruby and others.

#. Interfaces are methods.  An interface consists of the mere name of a method.

#. Coroutines. Python 2.5 generalized generators are used to stream data between components.

#. Jackson Structured Programming as a means to do program decomposition.

#. Observable pattern, as a means to define dependencies and facilitate communication.

None of these concepts is new, in fact most of them are very old and only reused here. They are shortly described below.

Interfaces are methods
~~~~~~~~~~~~~~~~~~~~~~
An interface facilitates the exchange of messages.  A message is a method with arguments and a return value, just as you have many of them in any program::

    <value> = <message>(*args, **kwargs)

For example::

    write(file, mode='b')
    hits = query('title: green')

The message signature is the primary and sole point of interaction between components. Components send messages according to their signature, but without regard to their implementation, and components implement messages with respect to the message signature only.

An component is said to implement an interface ``a`` if and only if it has a method with name ``a``. No other parts of the signature are taken into account.  It is up to the components to provide c.q. understand the arguments.

Observer Pattern
~~~~~~~~~~~~~~~~~
The Library arranges components into a graph of observers.  For more information on the observer pattern, see *Gamma et. al. Design Patterns, Elements of Reusable Object-Oriented Software, 1995*.

When a component sends a message, only its observers will receive it.

Coroutines
~~~~~~~~~~
Pythons (as do other languages) supports the concept of generators.  A generator is a method with multiple entry points, at each of which it can exchange arguments with it's caller.  Standard Python does not support program decomposition with generators like one would do with methods.  The Component Library solves this problem by means of the ``compose`` functionality.  The Library uses this concept for the ``all`` primitive.

Jackson Structured Programming (JSP)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Introduced more than 30 years ago by Michal Jackson to enable the processing of large amounts of data with a system containing only limited memory, it's relevance for today's web-servers is striking.  JSP describes a way of connecting coroutines to efficiently process datarecords while maintaining a simple code base. The Component Library supports and recommends the use of JSP, although this is not obligatory.  For more information, the reader is refered to the web.

Components
----------
A component might send messages (or *use* interfaces), implement messages (or *support* interfaces) or do both.

Implementing messages
~~~~~~~~~~~~~~~~~~~~~
A component in the Library consists of a normal Python class::

    class MyComponent(object):
        pass

This class can implement any messages by providing methods with the correct signature. There is no restriction on the type of methods, nor on their name nor on their arguments.  The component below support the interface ``myPublicMethod``::

    class MyComponent(object):
        def myPublicMethod(self, arg1, arg2=None):
            pass

As one can see, this is a normal Python class, without any constraints.

Sending messages
~~~~~~~~~~~~~~~~
A component sending messages must extend Observable, as components are connected by means of the Observable pattern::

    from mereso import Observable
    class OtherComponent(Observable):
        pass

Calling a public method of another component can be done with ``all``, ``any``, ``do`` or ``once``::

    class OtherComponent(Observable):
        def myMethod(self):
            for response in self.all.retrieveRecord(record=10):
                print response
            response = self.any.recordExists(record=10)
            self.do.updateRecord(record=10, ...)
            self.once.done()

The send via ``all`` will find all observers implementing ``retrieveRecord``, returning a generator with which their responses might be retrieved.  The generator is empty when no observers implement the message. The actual sending of the messages is lazy and will not happen until the sender processes the generator.

The send through ``any`` will find the *first* observer that implements ``recordExists``, send it and return the response.  It in fact implements a synchronous method call.  It raises an error when no observers answers the message. The functionality of ``any`` is a proper subset of that of ``all`` and is formally expressed in terms of ``all``.

The call through ``do`` will find all components implementing ``retrieveRecord``, send the messages to all of them and ignore the response.  This in fact implements an event mechanism with synchronous events processing. The functionality of ``do`` is a proper subset of that of ``all` and is formally expressed in terms of `all``.

The call through ``once`` will find all observers *and* their observers recursively, send the message to all of them *once* and ignore the responses.  The message is sent only once to each component, even if this component appears multiple times in the graph of observers.

Dynamic Implementation Interface (DII)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Components can receive messages without actually implementing them.  This can be done by implementing the method ``unknown``::

    class MyComponent(object):
        def unknown(self, message, *args, **kwargs):
            pass

This will intercept all messages for which no specific implementation is found in the same class.  Unknown is required to return None or a generator with responses, just as ``all`` does.  The ``unknown`` method does not intercept calls through ``once``.

Dynamic Message Interface (DMI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Components can send unforeseen messages â with the name of the messages in a variable instead of an Python identifier â by sending ``unknown``::

    class MyComponent(Observable):
        def myMethod(self):
            self.all.unknown('getInfo', ...)

This will send the message ``getInfo`` using ``all``.  Calls via ``any`` and ``do`` work as expected, ``once`` semantics cannot be achieved by ``unknown``.   Both the DII and DMI are transparent to each other, so if a component does not respond to ``getInfo``, but has the DII implemented, its ``unknown`` will be called with ``getInfo``.

Dynamic Context Interface (DCI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Components can provide contexts that are accessible by all of its observers and their observers recursively.  When a component provides the context ``blackboard``, being a simple dictionary, it's descendants can access it using ``self.blackboard``::

    class MyComponent(Observable):
        def aMethodAccessingBlackboard(self):
            self.blackboard['trash'] = 'dump this'

It must derive from Observable.

The component providing the context ``blackboard`` can do so as follows::

    class ContextProvider(Observable):
        def aMethodInitiatingContext(self):
            __callstack_var_blackboard__ = {}
            for result in self.all.aMethodAccessingBlackboard():    [4]
                yield result                                        [5]

To ensures proper scoping in the event of multiple concurrent calls, the context is defined as a local, and hence put on the call stack.  This will cause it to be captured in the closure created when the generator for ``aMethodInitiatingContext`` is instantiated. To avoid terminating the closure (and the subsequent deletion of the local ``__callstack_var_blackboard__``), lines 4 and 5 make sure the generator will not exit until all results from its descendants are processed.


Application DNA
===============
The DNA allows the program designer to select components to be used by instantiating the components and put them in the DNA.  The DNA defines the hierarchy of the components and provides configuration information for each of them.

Configuration
-------------

Component Instantiation
~~~~~~~~~~~~~~~~~~~~~~~
Component instantiation is normal Python object instantiation by calling constructors.  The constructors take configuration information.  Important: see `Component Design Guidelines`_ for some guidelines on this topic!

Simple Observer configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Components are connected to each other in a graph of observers.   Components only react to a message sent by another component if and when they are observers of that component.  The graph often contains one or more components that generate events based on input, for example from a network connection.  The leaves of the graph are often components that store something in a database or file system.  The components in between often do data processing or filtering.
A component derives from Observable and thereby inherits the addObserver method that can be used to register another component as listener to messages send by it::

    class My1Component(Observable):
        pass
    class My2Component(object):
        def aMessage(self):
            pass
    component1 = My1Component()
    component2 = My2Component()
    component1.addObserver(component2)

DNA Configuration
~~~~~~~~~~~~~~~~~
The DNA defines the hierarchy of the components and provides configuration information for each of them. The DNA is a recursively defined list of components with their configuration information fed to their constructors::

    dna = (Component1(configuration), dna-1, ..., dna-n)

This makes ``dna-1`` to ``dna-n`` listen to messages from Component1. This can go on indefinitely.  The following DNA lets Component3 listen to Component2, which together with Component4 listens to Component1::

    dna = (Component1(configuration1),
              (Component2(configuration2),
                  (Component3(configuration3),)
              ),
              (Component4(configuration4),)
          )

DNA strings such as above can be activated by calling ``be``, for example::

    from mereso import be
    server = be(dna)

This will cause the relations as described by the ``dna`` to be activated, which will cause all obeservers being registered with the proper observables.

Component Design Guidelines
---------------------------
There is no obligation to provide constructors, nor are there any rules as to what must be accepted or not.  However, the Library's purpose is to get rid of feeding dependencies, classes or factories to components using constructors, so it is recommended to avoid these and use ``self.[all|any|do]`` instead, see (1) below.  Also, it is not forbidden but avoid reading configuration information from the environment or files but instead make each configuration option an argument of the constructor, see (2) below.

So instead of::

    class MyComponent:
        def __init__(self, storage):
            self._storage = storage                                 (1)
            self._prefix = os.environ['mycomponent.prefix']         (2)
        def doSomething(self, data, name):
            self._storage.save(data, name=self._prefix+name)

write::

    class MyComponent(Observable):
        def __init__(self, prefix):
            self._prefix = prefix                                   (2)
        def doSomething(self, data, name):
            self.any.save(data, name=self._prefix+name)             (1)

and make sure that ``MyComponent`` is configured with a storage listening to save::

    myComponent = MyComponent()
    myComponent.addObserver(storage)

